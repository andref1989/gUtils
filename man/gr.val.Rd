% Generated by roxygen2 (4.0.2): do not edit by hand
\name{gr.val}
\alias{gr.val}
\title{gr.val}
\usage{
gr.val(query, target, val = NULL, mean = TRUE, weighted = mean,
  na.rm = F, by = NULL, by.prefix = val, merge = FALSE,
  verbose = FALSE, FUN = NULL, ignore.strand = TRUE, default.val = NA,
  max.slice = Inf, mc.cores = 1, ..., sep = ", ")
}
\arguments{
\item{query}{GRanges of query ranges whose "val" column we will populate with aggregated values of target}

\item{target}{GRanges of target ranges that already have "val" column populated}

\item{val}{dummy}

\item{mean}{scalar logical flag if FALSE then will return sum instead of mean, only applies if target "val" column i snumeric}

\item{weighted}{Default \code{mean}}

\item{na.rm}{Default FALSE}

\item{by}{scalar character, specifies additional "by" column of query AND target that will be used to match up query and target pairs (i.e. in addition to pure GRanges overlap), default is NULL}

\item{by.prefix}{Default \code{val}}

\item{merge}{if merge = FALSE then will cross every range in query with every level of "by" in target (and create data matrix), otherwise will assume query has "by" and merge only ranges that have matching "by" values in both query and target}

\item{verbose}{Default FALSE}

\item{FUN}{takes two  arguments (value, na.rm = TRUE) if weighted = FALSE, and three (value, width, na.rm = TRUE) if weighted = TRUE}

\item{ignore.strand}{Default TRUE}

\item{default.val}{dummy}

\item{max.slice}{Default Inf}

\item{mc.cores}{Number of cores (only if query exceed \code{max.slice})}

\item{...}{params to be passed to gr.findoverlaps}

\item{sep}{scalar character, specifies character to use as separator when aggregating character "vals" from target, only applies if target is numeric}
}
\description{
annotates gr's in "query" with aggregated values of gr's in "target" in field "val"
}
\details{
If "val" is numeric: given "target" gr with value column "val" representing ranged data (ie segment intensities) computes the value
in each "query" gr as the weighted mean of its intersection with target (ie the target values weighted by the width
of the intersections).

applications include querying the average value of target across a given query interval (eg exon to gene pileup)
or recasting a high res tiling in terms of low res intervals.  Usually query intervals are bigger than the target intervals.

If "val" is a character field: then aggregation will paste together the (unique), verlapping values, collapsing by comma

returns query with the "val" field populated

Optional

query and target can be GRangesLists's, in which case val will refer to GRangesList level values fields
}

